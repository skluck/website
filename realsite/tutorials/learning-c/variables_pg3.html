<!DOCTYPE html>

<html>
<head>
	<meta charset="UTF-8">
	<title>Page 3: Variables</title>
	<style type="text/css">
		body
		{
			font-family: "Times New Roman", Georgia, Serif;
		}

		.subheading
		{
			position: relative;
			top: -15px;
		}
	</style>
</head>

<body>
	<a href="/realsite/index.html">Home</a> <br>
	<a href="/realsite/tutorials/learning-c/helloworld_pg2.html">Back to Page 2: Hello, World!</a>

	<h1>Page 3: Variables</h1>
	<h4 class="subheading"><em>Fun fact: not all types in C have definite sizes. Many depend on the system.</em></h4>

	<h2>Types</h2>
	<p>
	Like many other languages, C has a wide array of variable types. <br>
	However, what really distinguishes C is its ability to reinterpret its various integral types in incredibly useful ways. <br>
	</p>
	Here are C's primitive data types:
	<ul>
		<li><code>char</code> - defined to be <em>exactly</em> 8 bits, or 1 byte.</li>
		<li><code>short</code> - defined to be <em>no less than</em> 16 bits, or 2 bytes.</li>
		<li><code>int</code> - defined to be <em>no less than</em> 16 bits, or 2 bytes. However, most modern systems have 32-bit, or 4-byte, ints.</li>
		<li><code>long</code> - defined to be <em>no less than</em> 32 bits or 2 bytes. On LP64 systems (64-bit OS X, 64-bit Linux), <code>long</code> should be 64 bits, or 8 bytes. On LLP64 systems like 64-bit Windows, <code>long</code> is 32-bits.</li>
		<li><code>long long</code> - defined to be <em>no less than</em> 64 bits or 8 bytes. On LP64 systems, there is no difference between <code>long</code> and <code>long long</code>. 
		<li><code>float</code> - defined to obey IEEE 754 with a precision of <em>no less than</em> 6.</li>
		<li><code>double</code> - defined to obey IEEE 754 with a precision of <em>no less than</em> 10.</li>
	</ul>
	Many of these are macroed or typedefed to other, more specific types defined in <code>&lt;types.h&gt;</code> (on Linux and Unix) and <code>&lt;stdint.h&gt;</code> (cross-platform). <br>

	<strong>Here is where it gets complicated: </strong> <br>

	<h3>Pointer Types</h3>
	<p>
	Each primitive type in C has a corresponding <em>pointer type</em>. <br>
	For example, the int pointer (<code>int *</code>) is a pointer to an address containing an integer. <br>
	Because pointers represent addresses in memory, they are always the size of the operating system's word, or native datum. For example, 32-bit systems will have 32-bit pointers.
	</p>

	<h3>Signed and Unsigned</h3>
	<p>
	Just as each type has a corresponding pointer type, each type <em>also</em> has two variations: signed and unsigned. <br>
	When declaring a variable without explicitly requesting signage, it is up to the system to determine whether or not to use signed types. Many systems use signed types by default, but it isn't guaranteed. <br>
	Signed and unsigned variables of the same type take up the same amount of space. However, the way they use that space is what differentiates them. <br>
	<strong>Signed variables</strong> reserve a "sign bit," allowing them to represent both positive and negative numbers, at the cost of 1 bit off of the maximum number. <br> 
	<strong>Unsigned variables</strong> do not reserve a sign bit. This allows them to represent the largest number possible within their allocated number of bits, but prevents them from repsenting negative numbers.
	</p>

	<h3>Duration Specifiers</h3>
	<p>
	Unfortunately, it doesn't end there. <br>
	C also has <em>duration specifiers</em>, which act as compiler hints towards the location of variables. <br>
	There are four primary specifiers: <br>
	<ul>
		<li><code>auto</code> - A redundant specifier. You should never need to use it.</li>
		<li><code>register</code> - Suggests that the speficied variable be stored in a CPU register. Most modern compilers automatically optimize and determine which variables are best suited for registers, making this <em>largely</em> redundant. An important side-effect of the <code>register</code> specifier is that variables declared with it cannot have their addresses determined.</li>
		<li><code>static</code> - Specifies the give variable to be initialized to zero, unlike the typical "undefined" value. The <code>static</code> specifier also places a variable in the scope of the entire program (not just a particular function block or scope) for the entire duration of execution.</li>
		<li><code>extern</code> - Indicates that the variable has been previously defined outside of the current scope or block.</li>
	</ul>
	</p>

	There are a few other keywords like <code>const</code> and <code>volatile</code>, but we don't have to go into too much detail about them right now.

	<h3>Where are my <code>public</code> and <code>private</code>?</h3>
	<p>
	Coming from a language like C++, Java, or C#, you may find it unusual that C has no concept of public, protected, or private variables. However, they really aren't necessary. <br>
	Without complex data structures like objects or the inheritance rules that follow them, it's really not necessary to limit the visibility of variables across the runtime.
	</p>

	<a href="/realsite/tutorials/learning-c/pointers_arrays_pg4.html">Page 4: Pointers and Arrays</a>
</body>
</html>
